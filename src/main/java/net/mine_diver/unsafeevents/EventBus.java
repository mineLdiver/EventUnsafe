package net.mine_diver.unsafeevents;

import com.google.common.collect.ObjectArrays;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import it.unimi.dsi.fastutil.ints.Int2ReferenceMap;
import it.unimi.dsi.fastutil.ints.Int2ReferenceOpenHashMap;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;
import net.jodah.typetools.TypeResolver;
import net.mine_diver.unsafeevents.listener.EventListener;
import net.mine_diver.unsafeevents.listener.ListenerPriority;
import net.mine_diver.unsafeevents.util.Util;
import net.mine_diver.unsafeevents.util.collection.Int2ReferenceArrayMapWrapper;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.lang.invoke.MethodHandles;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.function.Consumer;
import java.util.function.IntFunction;

/**
 * The basic {@link EventBus} implementation.
 *
 * <p>
 *     This implementation is usually the fastest for dispatching events and registering listeners.
 * </p>
 *
 * <p>
 *     {@link EventBus} is designed to contain listeners separate from each other,
 *     allowing to have separate sets of listeners for each event per bus.
 *     Unless registered in both buses, listeners aren't shared between them.
 * </p>
 *
 * <p>
 *     The listeners can be registered using 11 different {@code register()} methods, all of which
 *     have nearly the same performance for dispatching, but different listener code design and registering performance.
 * </p>
 *
 * <p>
 *     Allows extending for other implementations.
 * </p>
 *
 * @see EventListener
 * @see Event
 * @author mine_diver
 */
public class EventBus {

    /**
     * {@link DeadEvent} fallback.
     *
     * <p>
     *     This is the default listener for {@link DeadEvent},
     *     made to prevent recursion when there's no {@link DeadEvent} listeners registered.
     * </p>
     */
    @NotNull
    protected static final Consumer<@NotNull Event> DEAD_EVENT_FALLBACK = event -> { /* no need for implementation, empty */ };

    /**
     * Default listener for all events.
     *
     * <p>
     *     When there's no listeners registered for an event,
     *     this listener is executed instead to notify all {@link DeadEvent} listeners.
     * </p>
     */
    @NotNull
    protected final Consumer<@NotNull Event> DEAD_EVENT = event -> {
        // setting up DeadEvent
        final @NotNull DeadEvent deadEvent = DeadEvent.INSTANCE;
        deadEvent.event = event;
        // dispatching
        post(deadEvent);
    };

    /**
     * {@link ListenerRegistryFactory} containing this bus's instance and lookup.
     *
     * <p>
     *     Used for generating high performance event dispatch registries
     *     with this bus's listeners that are stored in {@link EventBus#listeners}.
     * </p>
     *
     * @see ListenerRegistryFactory
     */
    @NotNull
    protected final ListenerRegistryFactory listenerRegistryFactory = new ListenerRegistryFactory(this, MethodHandles.lookup());

    /**
     * {@link Int2ReferenceMap} containing this bus's listeners.
     * Key is the event ID, value is the array of listener containers sorted in reverse by priority.
     *
     * <p>
     *     Used for generating dispatch registries with {@link EventBus#listenerRegistryFactory},
     *     not used for dispatching listeners directly due to low performance
     *     of iterating over an array and looking up a value in a map.
     * </p>
     *
     * @see ListenerContainer
     */
    @NotNull
    protected final Int2ReferenceMap<ListenerContainer[]> listeners = new Int2ReferenceOpenHashMap<>();

    /**
     * The field containing high performance registries generated by {@link EventBus#listenerRegistryFactory}.
     *
     * <p>
     *     The index is the event ID, the element is the registry.
     * </p>
     *
     * <p>
     *     All interactions with this array (except for getting an element)
     *     must be done through {@link EventBus#registries} array map wrapper,
     *     as it contains the necessary safeguards and array reallocation functionality needed to operate
     *     with this similar to a {@link Int2ReferenceMap} but with better performance and
     *     JIT inlining capabilities.
     * </p>
     *
     * <p>
     *     The default element of this array is {@link EventBus#DEAD_EVENT}.
     *     The {@link DeadEvent} registry is set to {@link EventBus#DEAD_EVENT_FALLBACK} by default.
     * </p>
     *
     * @see EventBus#registries
     * @see Int2ReferenceArrayMapWrapper
     */
    protected @NotNull Consumer<Event>[] registriesArray;

    /**
     * Array map wrapper of {@link EventBus#registriesArray}.
     *
     * <p>
     *     Used for map-like interaction with {@link EventBus#registriesArray}.
     * </p>
     *
     * <p>
     *     Default value is {@link EventBus#DEAD_EVENT}, initial capacity is set to {@link Event#NEXT_ID} + 1.
     *     The {@link DeadEvent} registry is set to {@link EventBus#DEAD_EVENT_FALLBACK} by default.
     * </p>
     *
     * @see EventBus#registriesArray
     * @see Int2ReferenceArrayMapWrapper
     */
    @NotNull
    protected final Int2ReferenceArrayMapWrapper<Consumer<@NotNull Event>> registries = Util.make(new Int2ReferenceArrayMapWrapper<>(
            () -> registriesArray,                                                        // the array getter
            arr -> registriesArray = arr,                                                 // the array setter
            (IntFunction<@NotNull Consumer<@NotNull Event> @NotNull []>) Consumer[]::new, // the array constructor
            DEAD_EVENT, Event.NEXT_ID.get() + 1
    ), wrapper -> wrapper.put(DeadEvent.ID, DEAD_EVENT_FALLBACK));

    /**
     * {@link IntSet} of event IDs under which high performance registries
     * inside {@link EventBus#registriesArray} do not match raw
     * {@link EventBus#listeners} and require recompilation.
     * 
     * <p>
     *     This is done to allow for lazy recompilation of high performance registries
     *     during event dispatching, saving memory and CPU operations during
     *     registration of new listeners.
     * </p>
     * 
     * @see EventBus#post(Event)
     * @see EventBus#invalidated
     * @see EventBus#compileRegistries()
     */
    @NotNull
    protected final IntSet invalidatedRegistries = new IntOpenHashSet();

    /**
     * Indicates that there were new listeners registered and {@link EventBus#invalidatedRegistries} is not empty.
     *
     * <p>
     *     This allows for a high performance check during event dispatching.
     * </p>
     *
     * @see EventBus#post(Event)
     * @see EventBus#compileRegistries()
     * @see EventBus#invalidatedRegistries
     */
    protected boolean invalidated;

    /**
     * Registers only static methods annotated with {@link EventListener}
     * in the specified class as listeners in this bus.
     *
     * @param listenerClass the class containing static {@link EventListener} methods.
     * @throws IllegalArgumentException if an {@link EventListener} method in the hierarchy
     *                                  has no or more than 1 parameters, or if the method parameter is not an event
     */
    public void register(
            final @NotNull Class<?> listenerClass
    ) {
        register(listenerClass, null);
    }

    /**
     * Registers only non-static methods annotated with {@link EventListener}
     * in the class of the specified object.
     *
     * <p>
     *     The listeners are only registered under this object's instance.
     * </p>
     *
     * @param listener the object which class contains non-static {@link EventListener} methods.
     * @throws IllegalArgumentException if an {@link EventListener} method in the hierarchy
     *                                  has no or more than 1 parameters, or if the method parameter is not an event
     */
    public void register(
            final @NotNull Object listener
    ) {
        register(listener.getClass() /* getting all the methods of the hierarchy */, listener);
    }

    /**
     * Registers this object's methods from a class somewhere in the hierarchy of this object.
     *
     * <p>
     *     Allows to limit the bus to only registering methods starting from a specific point in the hierarchy of this object.
     *     For example, class B extends class A. If {@code register(A.class, new B())} is run,
     *     only the {@link EventListener} methods of class A are going to be registered, but associated to an instance of B.
     *     If {@code register(B.class, new B())} is run, both class A and class B {@link EventListener} methods are going to
     *     be registered.
     * </p>
     *
     * <p>
     *     If listener instance is null, only static {@link EventListener} methods are going to be registered,
     *     otherwise static methods are ignored and only non-static methods are registered.
     * </p>
     *
     * @param listenerClass the listener class starting from which in the hierarchy the {@link EventListener} methods are registered.
     * @param listener the listener object. If null, static {@link EventListener} methods are registered instead.
     * @param <T> the instance type.
     * @param <U> a child type of instance, allows to specify higher hierarchy types, including {@link T}, for listener class type.
     * @throws IllegalArgumentException if an {@link EventListener} method in the hierarchy
     *                                  has no or more than 1 parameters, or if the method parameter is not an event
     */
    public <T, U extends T> void register(
            final @NotNull Class<? super U> listenerClass,
            final @Nullable T listener
    ) {
        for (final @NotNull Method method : listenerClass.getDeclaredMethods())
            if (method.isAnnotationPresent(EventListener.class) && ((listener == null) == Modifier.isStatic(method.getModifiers()))) {
                final @NotNull EventListener eventListener = method.getAnnotation(EventListener.class);
                final @NotNull ListenerPriority listenerPriority = eventListener.priority();
                register(method, listener, listenerPriority.custom ? eventListener.numPriority() : listenerPriority.numPriority);
            }
    }

    /**
     * Registers a static {@link EventListener} {@link Method} with {@link EventListener#DEFAULT_PRIORITY} priority.
     *
     * @param method the static {@link EventListener} method to register as a listener.
     * @throws IllegalArgumentException if the method has no or more than 1 parameters,
     *                                  or if the method parameter is not an event
     */
    public void register(
            final @NotNull Method method
    ) {
        register(method, null);
    }

    /**
     * Registers a static {@link EventListener} {@link Method} with a custom priority.
     *
     * @param method the static {@link EventListener} method to register as a listener.
     * @param priority the priority to assign to this listener.
     * @throws IllegalArgumentException if the method has no or more than 1 parameters,
     *                                  or if the method parameter is not an event
     * @see ListenerPriority
     */
    public void register(
            final @NotNull Method method,
            final int priority
    ) {
        register(method, null, priority);
    }

    /**
     * Registers an {@link EventListener} {@link Method} with {@link EventListener#DEFAULT_PRIORITY} priority.
     *
     * <p>
     *     If listener instance is null, the {@link EventListener} method is registered as static.
     * </p>
     *
     * @param method the {@link EventListener} method to register as a listener.
     * @param listener the listener object. If null, the method is registered as static.
     * @throws IllegalArgumentException if the method has no or more than 1 parameters,
     *                                  or if the method parameter is not an event
     */
    public void register(
            final @NotNull Method method,
            final @Nullable Object listener
    ) {
        register(method, listener, EventListener.DEFAULT_PRIORITY);
    }

    /**
     * Registers an {@link EventListener} {@link Method} with a custom priority.
     *
     * <p>
     *     If listener instance is null, the {@link EventListener} method is registered as static.
     * </p>
     *
     * @param method the {@link EventListener} method to register as a listener.
     * @param listener the listener object. If null, the method is registered as static.
     * @param priority the priority to assign to this listener.
     * @param <T> the event type.
     * @throws IllegalArgumentException if the method has no or more than 1 parameters,
     *                                  or if the method parameter is not an event
     */
    public <T extends Event> void register(
            final @NotNull Method method,
            final @Nullable Object listener,
            final int priority
    ) {
        if (method.getParameterCount() == 1) {
            final @NotNull Class<?> rawEventType = method.getParameterTypes()[0]; // getting the method parameter type
            if (Event.class.isAssignableFrom(rawEventType)) {
                //noinspection unchecked
                final @NotNull Class<T> eventType = (Class<T>) rawEventType; // casting the method parameter type to the event type
                register(
                        eventType,
                        ListenerExecutorFactory.create(listener, method, eventType), // creating a high performance executor for this method
                        priority
                );
            } else throw new IllegalArgumentException(String.format(
                    "Method %s#%s's parameter type (%s) is not an event!",
                    method.getDeclaringClass().getName(), method.getName(), rawEventType.getName()
            ));
        } else throw new IllegalArgumentException(String.format(
                "Method %s#%s has a wrong amount of parameters!",
                method.getDeclaringClass().getName(), method.getName()
        ));
    }

    /**
     * Registers an {@link Event} {@link Consumer} as a listener with {@link EventListener#DEFAULT_PRIORITY} priority.
     *
     * <p>
     *     This method automatically resolves the event type from the consumer's parameters.
     * </p>
     *
     * @param listener the consumer to register as a listener.
     * @param <T> the event type.
     */
    public <T extends Event> void register(
            final @NotNull Consumer<@NotNull T> listener
    ) {
        register(listener, EventListener.DEFAULT_PRIORITY);
    }

    /**
     * Registers an {@link Event} {@link Consumer} as a listener with a custom priority.
     *
     * <p>
     *     This method automatically resolves the event type from the consumer's parameters.
     * </p>
     *
     * @param listener the consumer to register as a listener.
     * @param priority the priority to assign to this listener.
     * @param <T> the event type.
     */
    public <T extends Event> void register(
            final @NotNull Consumer<@NotNull T> listener,
            final int priority
    ) {
        //noinspection unchecked
        register(
                (Class<T>) TypeResolver.resolveRawArgument(Consumer.class, listener.getClass()), // resolving the event type from consumer's parameters
                listener,
                priority
        );
    }

    /**
     * Registers an {@link Event} {@link Consumer} as a listener with {@link EventListener#DEFAULT_PRIORITY} priority.
     *
     * @param eventType the event type class. Skips the automatic resolving.
     * @param listener the consumer to register as a listener.
     * @param <T> the event type.
     */
    public <T extends Event> void register(
            final @NotNull Class<T> eventType,
            final @NotNull Consumer<@NotNull T> listener
    ) {
        register(eventType, listener, EventListener.DEFAULT_PRIORITY);
    }

    /**
     * Registers an {@link Event} {@link Consumer} as a listener with a custom priority.
     *
     * @param eventType the event type class. Skips the automatic resolving.
     * @param listener the consumer to register as a listener.
     * @param priority the priority to assign to this listener.
     * @param <T> the event type.
     */
    public <T extends Event> void register(
            final @NotNull Class<T> eventType,
            final @NotNull Consumer<@NotNull T> listener,
            final int priority
    ) {
        final int globalId = Event.getEventID(eventType);
        //noinspection unchecked
        final @NotNull ListenerContainer listenerContainer = new ListenerContainer((Consumer<Event>) listener, priority);
        // putting the listener into raw listeners array and sorting by priority
        Arrays.sort(listeners.compute(
                globalId,
                (id, containers) -> containers == null ?
                        new ListenerContainer[] { listenerContainer } :
                        ObjectArrays.concat(containers, listenerContainer)
        ));
        // invalidating the state to schedule a recompile of high performance registries during the next event dispatch
        invalidatedRegistries.add(globalId);
        invalidated = true;
    }

    /**
     * Compiles high performance registries that are invalidated through {@link EventBus#invalidatedRegistries}.
     *
     * @see EventBus#post(Event)
     * @see EventBus#invalidated
     * @see EventBus#invalidatedRegistries
     */
    protected void compileRegistries() {
        invalidatedRegistries.iterator().forEachRemaining(registryId -> {
            final @NotNull ListenerContainer[] listenerContainers = listeners.get(registryId);
            //noinspection unchecked
            registries.put(
                    registryId,
                    listenerContainers.length == 1 ?
                            listenerContainers[0].invoker() :
                            listenerRegistryFactory.create(
                                    Arrays.stream(listenerContainers)
                                            .map(ListenerContainer::invoker)
                                            .toArray(Consumer[]::new)
                            )
            );
        });
        // validating the state
        invalidatedRegistries.clear();
        invalidated = false;
    }

    /**
     * Event dispatch method.
     *
     * <p>
     *     Invokes all listeners of the specified event through a high performance registry.
     * </p>
     *
     * <p>
     *     If the bus state is invalidated, the invalidated high performance registries are recompiled.
     *     If the event ID exceeds {@link EventBus#registriesArray} length, the array is resized.
     *     Both checks are simple and don't add too much overhead to the dispatch.
     * </p>
     *
     * <p>
     *     After the dispatch, {@link Event#finish()} is executed,
     *     allowing the event to perform some post-dispatch action,
     *     for example, a clean up of event parameters.
     * </p>
     *
     * @param event the event to dispatch to this bus's listeners.
     * @return the dispatched event.
     * @param <T> the event type.
     */
    @Contract("_ -> param1")
    @CanIgnoreReturnValue
    public @NotNull <T extends Event> T post(final @NotNull T event) {
        if (invalidated) compileRegistries(); // compiling high performance registries if the state is invalidated
        final int eventId = event.getEventID();
        if (eventId >= registriesArray.length) registries.resizeArray(eventId + 1); // resizing the array to fit the new event id
        registriesArray[eventId].accept(event); // dispatch
        event.finish(); // performing a finalization
        return event; // returning the event to allow for a one line check of a parameter in the event
    }
}
