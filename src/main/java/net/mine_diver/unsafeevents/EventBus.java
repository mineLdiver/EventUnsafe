package net.mine_diver.unsafeevents;

import com.google.common.collect.ObjectArrays;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import it.unimi.dsi.fastutil.ints.Int2ReferenceMap;
import it.unimi.dsi.fastutil.ints.Int2ReferenceOpenHashMap;
import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
import it.unimi.dsi.fastutil.ints.IntSet;
import net.mine_diver.unsafeevents.listener.EventListener;
import net.mine_diver.unsafeevents.listener.GenericListener;
import net.mine_diver.unsafeevents.listener.SingularListener;
import net.mine_diver.unsafeevents.util.Util;
import net.mine_diver.unsafeevents.util.collection.Int2ReferenceArrayMapWrapper;
import net.mine_diver.unsafeevents.util.exception.DisabledDispatchCause;
import net.mine_diver.unsafeevents.util.exception.IllegalDispatchException;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.lang.invoke.MethodHandles;
import java.util.Arrays;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.IntFunction;

/**
 * The basic {@link EventBus} implementation.
 *
 * <p>
 *     This implementation is usually the fastest for dispatching events and registering listeners.
 * </p>
 *
 * <p>
 *     {@link EventBus} is designed to contain listeners separate from each other,
 *     allowing to have separate sets of listeners for each event per bus.
 *     Unless registered in both buses, listeners aren't shared between them.
 * </p>
 *
 * <p>
 *     The listeners can be registered using 11 different {@code register()} methods, all of which
 *     have nearly the same performance for dispatching, but different listener code design and registering performance.
 * </p>
 *
 * <p>
 *     Allows extending for other implementations.
 * </p>
 *
 * @see EventListener
 * @see Event
 * @author mine_diver
 */
public class EventBus {
    /**
     * {@link DeadEvent} fallback.
     *
     * <p>
     *     This is the default listener for {@link DeadEvent},
     *     made to prevent recursion when there's no {@link DeadEvent} listeners registered.
     * </p>
     */
    @NotNull
    protected static final Consumer<@NotNull Event> DEAD_EVENT_FALLBACK = event -> { /* no need for implementation, empty */ };

    /**
     * Default listener for all events.
     *
     * <p>
     *     When there's no listeners registered for an event,
     *     this listener is executed instead to notify all {@link DeadEvent} listeners.
     * </p>
     */
    @NotNull
    protected final Consumer<@NotNull Event> DEAD_EVENT = event -> {
        // setting up DeadEvent
        final @NotNull DeadEvent deadEvent = DeadEvent.INSTANCE;
        deadEvent.event = event;
        // dispatching
        post(deadEvent);
    };

    /**
     * {@link ListenerRegistryFactory} containing this bus's instance and lookup.
     *
     * <p>
     *     Used for generating high performance event dispatch registries
     *     with this bus's listeners that are stored in {@link EventBus#listeners}.
     * </p>
     *
     * @see ListenerRegistryFactory
     */
    @NotNull
    protected final ListenerRegistryFactory listenerRegistryFactory = new ListenerRegistryFactory(this, MethodHandles.lookup());

    /**
     * {@link Int2ReferenceMap} containing this bus's listeners.
     * Key is the event ID, value is the array of listener containers sorted in reverse by priority.
     *
     * <p>
     *     Used for generating dispatch registries with {@link EventBus#listenerRegistryFactory},
     *     not used for dispatching listeners directly due to low performance
     *     of iterating over an array and looking up a value in a map.
     * </p>
     *
     * @see ListenerContainer
     */
    @NotNull
    protected final Int2ReferenceMap<ListenerContainer[]> listeners = new Int2ReferenceOpenHashMap<>();

    /**
     * The field containing high performance registries generated by {@link EventBus#listenerRegistryFactory}.
     *
     * <p>
     *     The index is the event ID, the element is the registry.
     * </p>
     *
     * <p>
     *     All interactions with this array (except for getting an element)
     *     must be done through {@link EventBus#registries} array map wrapper,
     *     as it contains the necessary safeguards and array reallocation functionality needed to operate
     *     with this similar to a {@link Int2ReferenceMap} but with better performance and
     *     JIT inlining capabilities.
     * </p>
     *
     * <p>
     *     The default element of this array is {@link EventBus#DEAD_EVENT}.
     *     The {@link DeadEvent} registry is set to {@link EventBus#DEAD_EVENT_FALLBACK} by default.
     * </p>
     *
     * @see EventBus#registries
     * @see Int2ReferenceArrayMapWrapper
     */
    protected @NotNull Consumer<Event>[] registriesArray;

    /**
     * Array map wrapper of {@link EventBus#registriesArray}.
     *
     * <p>
     *     Used for map-like interaction with {@link EventBus#registriesArray}.
     * </p>
     *
     * <p>
     *     Default value is {@link EventBus#DEAD_EVENT}, initial capacity is set to {@link DeadEvent#ID} + 1.
     *     The {@link DeadEvent} registry is set to {@link EventBus#DEAD_EVENT_FALLBACK} by default.
     * </p>
     *
     * @see EventBus#registriesArray
     * @see Int2ReferenceArrayMapWrapper
     */
    @NotNull
    protected final Int2ReferenceArrayMapWrapper<Consumer<@NotNull Event>> registries = Util.make(new Int2ReferenceArrayMapWrapper<>(
            () -> registriesArray,                                                        // the array getter
            arr -> registriesArray = arr,                                                 // the array setter
            (IntFunction<@NotNull Consumer<@NotNull Event> @NotNull []>) Consumer[]::new, // the array constructor
            DEAD_EVENT, DeadEvent.ID + 1
    ), wrapper -> wrapper.put(DeadEvent.ID, DEAD_EVENT_FALLBACK));

    /**
     * {@link IntSet} of event IDs under which high performance registries
     * inside {@link EventBus#registriesArray} do not match raw
     * {@link EventBus#listeners} and require recompilation.
     * 
     * <p>
     *     This is done to allow for lazy recompilation of high performance registries
     *     during event dispatching, saving memory and CPU operations during
     *     registration of new listeners.
     * </p>
     * 
     * @see EventBus#post(Event)
     * @see EventBus#invalidated
     * @see EventBus#compileRegistries()
     */
    @NotNull
    protected final IntSet invalidatedRegistries = new IntOpenHashSet();

    /**
     * Indicates that there were new listeners registered and {@link EventBus#invalidatedRegistries} is not empty.
     *
     * <p>
     *     This allows for a high performance check during event dispatching.
     * </p>
     *
     * @see EventBus#post(Event)
     * @see EventBus#compileRegistries()
     * @see EventBus#invalidatedRegistries
     */
    protected boolean invalidated;

    /**
     * Whether dispatch is currently disabled.
     * False by default
     */
    protected boolean dispatchDisabled;

    /**
     * A throwable containing a stack trace of {@link #disableDispatch()}
     * as a cause for {@link IllegalDispatchException}, so debugging
     * an illegal dispatch is easier.
     */
    protected @Nullable DisabledDispatchCause disabledDispatchCause;

    /**
     * Disables dispatch.
     *
     * <p>
     *     Makes {@link #post(Event)} throw {@link IllegalDispatchException}
     *     with the cause being this method's stack trace.
     * </p>
     *
     * <p>
     *     Caller sensitive. Stores current stack trace, including caller class,
     *     for potential future reference if {@link #post(Event)}
     *     gets executed while disabled.
     * </p>
     *
     * <p>
     *     Useful for bulk registering listeners that aren't supposed
     *     to directly or indirectly dispatch an event during registration.
     * </p>
     */
    public void disableDispatch() {
        dispatchDisabled = true;
        disabledDispatchCause = new DisabledDispatchCause("Event dispatch was disabled");
    }

    /**
     * Re-enables dispatch and clears disable stack trace.
     */
    public void enableDispatch() {
        dispatchDisabled = false;
        disabledDispatchCause = null;
    }

    /**
     * Registers a generic listener.
     *
     * @param genericListener the listener to register.
     */
    public void register(final @NotNull GenericListener genericListener) {
        genericListener.accept(this::register);
    }

    /**
     * Registers a singular listener.
     *
     * @param listener the listener to register
     * @param <EVENT> the event type the listener accepts.
     */
    public <EVENT extends Event> void register(final @NotNull SingularListener<@NotNull EVENT> listener) {
        final int globalId = Event.getEventID(listener.eventType());
        //noinspection unchecked
        final @NotNull ListenerContainer listenerContainer = new ListenerContainer((Consumer<Event>) listener.listener(), listener.priority());
        // putting the listener into raw listeners array and sorting by priority
        Arrays.sort(listeners.compute(
                globalId,
                (id, containers) -> containers == null ?
                        new ListenerContainer[] { listenerContainer } :
                        ObjectArrays.concat(containers, listenerContainer)
        ));
        // invalidating the state to schedule a recompile of high performance registries during the next event dispatch
        invalidatedRegistries.add(globalId);
        invalidated = true;
    }

    /**
     * Compiles high performance registries that are invalidated through {@link EventBus#invalidatedRegistries}.
     *
     * @see EventBus#post(Event)
     * @see EventBus#invalidated
     * @see EventBus#invalidatedRegistries
     */
    protected void compileRegistries() {
        invalidatedRegistries.iterator().forEachRemaining(registryId -> {
            final @NotNull ListenerContainer[] listenerContainers = listeners.get(registryId);
            //noinspection unchecked
            registries.put(
                    registryId,
                    listenerContainers.length == 1 ?
                            listenerContainers[0].invoker() :
                            listenerRegistryFactory.create(
                                    Arrays.stream(listenerContainers)
                                            .map(ListenerContainer::invoker)
                                            .toArray(Consumer[]::new)
                            )
            );
        });
        // validating the state
        invalidatedRegistries.clear();
        invalidated = false;
    }

    /**
     * Event dispatch method.
     *
     * <p>
     *     Invokes all listeners of the specified event through a high performance registry.
     * </p>
     *
     * <p>
     *     If the bus state is invalidated, the invalidated high performance registries are recompiled.
     *     If the event ID exceeds {@link EventBus#registriesArray} length, the array is resized.
     *     Both checks are simple and don't add too much overhead to the dispatch.
     * </p>
     *
     * <p>
     *     After the dispatch, {@link Event#finish()} is executed,
     *     allowing the event to perform some post-dispatch action,
     *     for example, a clean up of event parameters.
     * </p>
     *
     * @param event the event to dispatch to this bus's listeners.
     * @return the dispatched event.
     * @param <T> the event type.
     * @throws IllegalDispatchException if dispatch was currently disabled
     */
    @Contract("_ -> param1")
    @CanIgnoreReturnValue
    public @NotNull <T extends Event> T post(final @NotNull T event) {
        if (dispatchDisabled) throw new IllegalDispatchException("Attempted to dispatch event " + event.getClass().getName() + " when dispatch is disabled!", Objects.requireNonNull(disabledDispatchCause, "Dispatch disable cause can't be null!"));
        if (invalidated) compileRegistries(); // compiling high performance registries if the state is invalidated
        final int eventId = event.getEventID();
        if (eventId >= registriesArray.length) registries.resizeArray(eventId + 1); // resizing the array to fit the new event id
        registriesArray[eventId].accept(event); // dispatch
        event.finish(); // performing a finalization
        return event; // returning the event to allow for a one line check of a parameter in the event
    }
}
